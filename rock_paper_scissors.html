<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Rock-Paper-Scissors Triangle Battle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1e1e2e 0%, #0a0a15 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #ffffff;
            overflow: hidden;
        }
        
        h1 {
            font-size: 2.5em;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(255, 255, 100, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(255, 255, 100, 0.3); }
            to { text-shadow: 0 0 30px rgba(255, 255, 100, 0.8); }
        }
        
        #gameCanvas {
            border: 3px solid #444;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            background: #000000;
            cursor: crosshair;
        }
        
        #stats {
            display: flex;
            gap: 40px;
            margin: 20px 0;
            font-size: 1.5em;
            font-weight: bold;
        }
        
        .stat {
            padding: 15px 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            min-width: 150px;
            text-align: center;
            transition: transform 0.3s;
        }
        
        .stat:hover {
            transform: scale(1.1);
        }
        
        #rockCount {
            background: linear-gradient(135deg, #ff3232 0%, #cc0000 100%);
        }
        
        #paperCount {
            background: linear-gradient(135deg, #3296ff 0%, #0050cc 100%);
        }
        
        #scissorCount {
            background: linear-gradient(135deg, #32ff64 0%, #00cc33 100%);
        }
        
        #controls {
            margin: 20px 0;
            font-size: 1.1em;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #winnerModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border-radius: 20px;
            border: 3px solid #ffd700;
            box-shadow: 0 0 100px rgba(255, 215, 0, 0.5);
            text-align: center;
            z-index: 1000;
        }
        
        #winnerModal.show {
            display: block;
            animation: popIn 0.5s ease-out;
        }
        
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0); }
            60% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        #winnerModal h2 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #ffd700;
        }
        
        .info {
            margin: 15px 0;
            color: #aaa;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <h1>üéÆ Rock-Paper-Scissors Triangle Battle</h1>
    
    <div id="stats">
        <div id="rockCount" class="stat">ü™® Rock: 30</div>
        <div id="paperCount" class="stat">üìÑ Paper: 30</div>
        <div id="scissorCount" class="stat">‚úÇÔ∏è Scissor: 30</div>
    </div>
    
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    
    <div id="controls">
        <button onclick="resetGame()">üîÑ Restart Game</button>
        <button onclick="togglePause()">‚è∏Ô∏è Pause/Resume</button>
    </div>
    
    <div class="info">
        Rules: ü™® beats ‚úÇÔ∏è | üìÑ beats ü™® | ‚úÇÔ∏è beats üìÑ
    </div>
    
    <div id="winnerModal">
        <h2 id="winnerText">üèÜ WINNER! üèÜ</h2>
        <button onclick="resetGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Constants
        const PARTICLE_RADIUS = 9;  // Even bigger for better visibility
        const PARTICLE_SPEED = 0.33125;  // 1.75x faster (was 0.075)
        const INITIAL_COUNT = 50;
        const CONVERSION_CHANCE = 0.15;  // 15% chance so conversions are visible
        const SHOW_TRAILS = false;  // No trails
        
        // Triangle setup
        const triangleSize = 400;
        const screenCenterX = canvas.width / 2;
        const screenCenterY = canvas.height / 2 + 50;
        
        // Calculate triangle vertices (equilateral triangle)
        const vertices = [
            { x: screenCenterX, y: screenCenterY - triangleSize }, // Top (A)
            { x: screenCenterX - triangleSize * Math.cos(Math.PI / 6), y: screenCenterY + triangleSize * Math.sin(Math.PI / 6) }, // Bottom-left (B)
            { x: screenCenterX + triangleSize * Math.cos(Math.PI / 6), y: screenCenterY + triangleSize * Math.sin(Math.PI / 6) }  // Bottom-right (C)
        ];
        
        // Calculate TRUE CENTROID (D) of the triangle
        // Centroid = average of all three vertices
        const centerX = (vertices[0].x + vertices[1].x + vertices[2].x) / 3;
        const centerY = (vertices[0].y + vertices[1].y + vertices[2].y) / 3;
        
        // Verify distances (for equilateral triangle, AD = BD = CD)
        const distAD = Math.sqrt(Math.pow(vertices[0].x - centerX, 2) + Math.pow(vertices[0].y - centerY, 2));
        const distBD = Math.sqrt(Math.pow(vertices[1].x - centerX, 2) + Math.pow(vertices[1].y - centerY, 2));
        const distCD = Math.sqrt(Math.pow(vertices[2].x - centerX, 2) + Math.pow(vertices[2].y - centerY, 2));
        /*
        console.log('Centroid Distances:');
        console.log('AD =', distAD.toFixed(2));
        console.log('BD =', distBD.toFixed(2));
        console.log('CD =', distCD.toFixed(2));
        console.log('All distances equal?', Math.abs(distAD - distBD) < 0.01 && Math.abs(distBD - distCD) < 0.01);
        */
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, type, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.type = type;
                this.color = color;
                this.lastConversion = 0;  // Frame counter for cooldown
                this.trail = [];  // Trail positions
                this.justConverted = 0;  // Flash effect when converted
            }
            
            update() {
                // Add current position to trail
                if (SHOW_TRAILS) {
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 15) {
                        this.trail.shift();
                    }
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.reflectAtEdges();
                
                // Decrease flash effect
                if (this.justConverted > 0) {
                    this.justConverted--;
                }
            }
            
            reflectAtEdges() {
                // Simple and robust reflection using distance to each edge
                let reflected = false;
                
                for (let i = 0; i < 3; i++) {
                    const v1 = vertices[i];
                    const v2 = vertices[(i + 1) % 3];
                    
                    // Edge vector and length
                    const ex = v2.x - v1.x;
                    const ey = v2.y - v1.y;
                    const edgeLen = Math.sqrt(ex * ex + ey * ey);
                    
                    // Edge unit vector
                    const edgeX = ex / edgeLen;
                    const edgeY = ey / edgeLen;
                    
                    // Inward normal (perpendicular to edge, pointing to center)
                    let nx = -edgeY;
                    let ny = edgeX;
                    
                    // Ensure normal points inward
                    const midX = (v1.x + v2.x) / 2;
                    const midY = (v1.y + v2.y) / 2;
                    const toCenterX = centerX - midX;
                    const toCenterY = centerY - midY;
                    
                    if (nx * toCenterX + ny * toCenterY < 0) {
                        nx = -nx;
                        ny = -ny;
                    }
                    
                    // Vector from edge start to particle
                    const toParticleX = this.x - v1.x;
                    const toParticleY = this.y - v1.y;
                    
                    // Distance from particle to edge (negative if outside)
                    const distToEdge = toParticleX * nx + toParticleY * ny;
                    
                    // If particle is outside (or very close to edge)
                    if (distToEdge < PARTICLE_RADIUS) {
                        // Reflect velocity off this edge
                        const velDotNormal = this.vx * nx + this.vy * ny;
                        
                        // Only reflect if moving towards edge
                        if (velDotNormal < 0) {
                            this.vx -= 2 * velDotNormal * nx;
                            this.vy -= 2 * velDotNormal * ny;
                            reflected = true;
                        }
                        
                        // Push particle back inside with margin
                        if (distToEdge < PARTICLE_RADIUS) {
                            const pushDist = PARTICLE_RADIUS - distToEdge + 1;
                            this.x += pushDist * nx;
                            this.y += pushDist * ny;
                        }
                    }
                }
            }
            
            draw() {
                // Pulsing effect for visibility
                const pulse = Math.sin(frameCount * 0.05) * 0.5 + 0.5;
                const glowSize = 20 + pulse * 10;
                
                // Draw outer glow
                ctx.shadowBlur = glowSize;
                ctx.shadowColor = this.color;
                
                // Extra bright glow if just converted
                if (this.justConverted > 0) {
                    ctx.shadowBlur = 40;
                    // Draw expanding flash ring
                    const flashProgress = 1 - (this.justConverted / 20);
                    const ringSize = PARTICLE_RADIUS + flashProgress * 20;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, ringSize, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${1 - flashProgress})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // White flash at center
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, PARTICLE_RADIUS + 3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.justConverted / 30})`;
                    ctx.fill();
                }
                
                // Draw main particle with gradient
                const gradient = ctx.createRadialGradient(
                    this.x - PARTICLE_RADIUS/3, 
                    this.y - PARTICLE_RADIUS/3, 
                    0, 
                    this.x, 
                    this.y, 
                    PARTICLE_RADIUS
                );
                
                // Lighter center, darker edge
                const lightColor = this.color.replace('#', '');
                const r = parseInt(lightColor.substr(0, 2), 16);
                const g = parseInt(lightColor.substr(2, 2), 16);
                const b = parseInt(lightColor.substr(4, 2), 16);
                
                gradient.addColorStop(0, `rgba(${Math.min(r + 50, 255)}, ${Math.min(g + 50, 255)}, ${Math.min(b + 50, 255)}, 1)`);
                gradient.addColorStop(1, this.color);
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, PARTICLE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // White border for clarity
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Reset shadow
                ctx.shadowBlur = 0;
            }
        }
        
        let particles = [];
        let paused = false;
        let gameOver = false;
        let animationId;
        let frameCount = 0;
        const COOLDOWN_FRAMES = 90;  // 1.5 second cooldown at 60 FPS
        
        // Helper function to generate random point INSIDE a triangle using barycentric coordinates
        function randomPointInTriangle(v0, v1, v2) {
            // Generate random barycentric coordinates
            let r1 = Math.random();
            let r2 = Math.random();
            
            // Ensure point is inside triangle
            if (r1 + r2 > 1) {
                r1 = 1 - r1;
                r2 = 1 - r2;
            }
            
            const r3 = 1 - r1 - r2;
            
            // Calculate actual point
            return {
                x: v0.x * r1 + v1.x * r2 + v2.x * r3,
                y: v0.y * r1 + v1.y * r2 + v2.y * r3
            };
        }
        
        // Helper to get point in specific sector of triangle
        function randomPointInSector(cornerVertex, vertex2, vertex3, centerPoint) {
            // Create smaller sub-triangle: corner, midpoint of edge1, midpoint of edge2
            const mid1 = {
                x: (cornerVertex.x + vertex2.x) / 2,
                y: (cornerVertex.y + vertex2.y) / 2
            };
            const mid2 = {
                x: (cornerVertex.x + vertex3.x) / 2,
                y: (cornerVertex.y + vertex3.y) / 2
            };
            
            // Generate random point in this sub-triangle
            return randomPointInTriangle(cornerVertex, mid1, mid2);
        }
        
        // Initialize particles
        function initParticles() {
            particles = [];
            
            // Center point D
            const centerPoint = { x: centerX, y: centerY };
            
            // Rocks from corner A (Top) - Flow towards center
            for (let i = 0; i < INITIAL_COUNT; i++) {
                // Random position around corner A
                const offsetX = (Math.random() - 0.5) * 80;
                const offsetY = (Math.random() - 0.5) * 80;
                const startX = vertices[0].x + offsetX;
                const startY = vertices[0].y + offsetY;
                
                // Direction towards center D with slight randomness
                const dx = centerPoint.x - startX;
                const dy = centerPoint.y - startY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                const speed = PARTICLE_SPEED * (0.8 + Math.random() * 0.4);
                const randomAngle = (Math.random() - 0.5) * 0.3; // Small random angle variance
                const angle = Math.atan2(dy, dx) + randomAngle;
                
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                particles.push(new Particle(
                    startX, startY,
                    vx, vy, 'rock', '#ff3232'
                ));
            }
            
            // Papers from corner B (Bottom-left) - Flow towards center
            for (let i = 0; i < INITIAL_COUNT; i++) {
                // Random position around corner B
                const offsetX = (Math.random() - 0.5) * 80;
                const offsetY = (Math.random() - 0.5) * 80;
                const startX = vertices[1].x + offsetX;
                const startY = vertices[1].y + offsetY;
                
                // Direction towards center D with slight randomness
                const dx = centerPoint.x - startX;
                const dy = centerPoint.y - startY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                const speed = PARTICLE_SPEED * (0.8 + Math.random() * 0.4);
                const randomAngle = (Math.random() - 0.5) * 0.3;
                const angle = Math.atan2(dy, dx) + randomAngle;
                
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                particles.push(new Particle(
                    startX, startY,
                    vx, vy, 'paper', '#3296ff'
                ));
            }
            
            // Scissors from corner C (Bottom-right) - Flow towards center
            for (let i = 0; i < INITIAL_COUNT; i++) {
                // Random position around corner C
                const offsetX = (Math.random() - 0.5) * 80;
                const offsetY = (Math.random() - 0.5) * 80;
                const startX = vertices[2].x + offsetX;
                const startY = vertices[2].y + offsetY;
                
                // Direction towards center D with slight randomness
                const dx = centerPoint.x - startX;
                const dy = centerPoint.y - startY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                const speed = PARTICLE_SPEED * (0.8 + Math.random() * 0.4);
                const randomAngle = (Math.random() - 0.5) * 0.3;
                const angle = Math.atan2(dy, dx) + randomAngle;
                
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                particles.push(new Particle(
                    startX, startY,
                    vx, vy, 'scissor', '#32ff64'
                ));
            }
        }
        
        // Check collision
        function checkCollision(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < PARTICLE_RADIUS * 2;
        }
        
        // Resolve battle
        function resolveBattle(p1, p2) {
            if (p1.type === p2.type) return;
            
            // Check cooldown - prevent rapid conversions
            if (frameCount - p1.lastConversion < COOLDOWN_FRAMES) return;
            if (frameCount - p2.lastConversion < COOLDOWN_FRAMES) return;
            
            // Only convert with certain probability to slow down the game
            if (Math.random() > CONVERSION_CHANCE) return;
            
            // Rock beats Scissor
            if (p1.type === 'rock' && p2.type === 'scissor') {
                p2.type = 'rock';
                p2.color = '#ff3232';
                p2.lastConversion = frameCount;
                p2.justConverted = 20;  // Flash for 20 frames
                p2.trail = [];  // Clear trail
            } else if (p2.type === 'rock' && p1.type === 'scissor') {
                p1.type = 'rock';
                p1.color = '#ff3232';
                p1.lastConversion = frameCount;
                p1.justConverted = 20;
                p1.trail = [];
            }
            // Paper beats Rock
            else if (p1.type === 'paper' && p2.type === 'rock') {
                p2.type = 'paper';
                p2.color = '#3296ff';
                p2.lastConversion = frameCount;
                p2.justConverted = 20;
                p2.trail = [];
            } else if (p2.type === 'paper' && p1.type === 'rock') {
                p1.type = 'paper';
                p1.color = '#3296ff';
                p1.lastConversion = frameCount;
                p1.justConverted = 20;
                p1.trail = [];
            }
            // Scissor beats Paper
            else if (p1.type === 'scissor' && p2.type === 'paper') {
                p2.type = 'scissor';
                p2.color = '#32ff64';
                p2.lastConversion = frameCount;
                p2.justConverted = 20;
                p2.trail = [];
            } else if (p2.type === 'scissor' && p1.type === 'paper') {
                p1.type = 'scissor';
                p1.color = '#32ff64';
                p1.lastConversion = frameCount;
                p1.justConverted = 20;
                p1.trail = [];
            }
        }
        
        // Count particles
        function countParticles() {
            const counts = { rock: 0, paper: 0, scissor: 0 };
            particles.forEach(p => counts[p.type]++);
            return counts;
        }
        
        // Update stats
        function updateStats() {
            const counts = countParticles();
            document.getElementById('rockCount').textContent = `ü™® Rock: ${counts.rock}`;
            document.getElementById('paperCount').textContent = `üìÑ Paper: ${counts.paper}`;
            document.getElementById('scissorCount').textContent = `‚úÇÔ∏è Scissor: ${counts.scissor}`;
            
            // Check win condition
            if (counts.rock === INITIAL_COUNT*3 || counts.paper === INITIAL_COUNT*3 || counts.scissor === INITIAL_COUNT*3) {
                if (!gameOver) {
                    gameOver = true;
                    let winner = counts.rock === INITIAL_COUNT*3 ? 'ü™® ROCK' : counts.paper === INITIAL_COUNT*3 ? 'üìÑ PAPER' : '‚úÇÔ∏è SCISSOR';
                    document.getElementById('winnerText').textContent = `üèÜ ${winner} WINS! üèÜ`;
                    document.getElementById('winnerModal').classList.add('show');
                }
            }
        }
        
        // Draw everything
        function draw() {
            // Clear canvas with fade effect for trails
            if (SHOW_TRAILS) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw triangle
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw medians from vertices to centroid D (to show it's center)
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            // A to D
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();
            
            // B to D
            ctx.beginPath();
            ctx.moveTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();
            
            // C to D
            ctx.beginPath();
            ctx.moveTo(vertices[2].x, vertices[2].y);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Draw center point D (centroid)
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#ffff00';
            ctx.shadowBlur = 3;
            ctx.shadowColor = '#ffff00';
            ctx.fillText('', centerX + 12, centerY + 5);
            
            // Draw corner labels with larger font and emojis
            ctx.font = 'bold 24px Arial';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#ff3232';
            ctx.fillStyle = '#ff3232';
            ctx.fillText('ü™® ROCK ', vertices[0].x - 60, vertices[0].y - 25);
            
            ctx.shadowColor = '#3296ff';
            ctx.fillStyle = '#3296ff';
            ctx.fillText('üìÑ PAPER ', vertices[1].x - 90, vertices[1].y + 35);
            
            ctx.shadowColor = '#32ff64';
            ctx.fillStyle = '#32ff64';
            ctx.fillText('‚úÇÔ∏è SCISSOR ', vertices[2].x + 10, vertices[2].y + 35);
            ctx.shadowBlur = 0;
            
            // Display centroid distances (for verification)
            ctx.font = 'bold 14px monospace';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            //ctx.fillText(`AD = ${distAD.toFixed(2)}`, 10, canvas.height - 60);
            //ctx.fillText(`BD = ${distBD.toFixed(2)}`, 10, canvas.height - 40);
            //ctx.fillText(`CD = ${distCD.toFixed(2)}`, 10, canvas.height - 20);
            
            // Draw particles
            particles.forEach(p => p.draw());
        }
        
        // Game loop
        function gameLoop() {
            if (!paused && !gameOver) {
                frameCount++;
                
                // Update particles
                particles.forEach(p => p.update());
                
                // Check collisions
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        if (checkCollision(particles[i], particles[j])) {
                            resolveBattle(particles[i], particles[j]);
                        }
                    }
                }
                
                updateStats();
            }
            
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // Reset game
        function resetGame() {
            gameOver = false;
            frameCount = 0;
            document.getElementById('winnerModal').classList.remove('show');
            initParticles();
            updateStats();
        }
        
        // Toggle pause
        function togglePause() {
            paused = !paused;
        }
        
        // Initialize and start
        initParticles();
        updateStats();
        gameLoop();
        
        console.log('üéÆ Game initialized! Watch the battle!');
    </script>
</body>
</html>

